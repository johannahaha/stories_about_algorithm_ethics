
const GlowingShader = {
    vertexShader: [
        'precision highp float;',
        'precision highp int;',
        'uniform mat3 normalMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 modelMatrix;',
        'uniform mat4 viewMatrix;',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        'varying vec3 fNormal;',
        'varying vec3 fPosition;',
        'varying vec2 vUv;',
        
        'vec4 transparent_main()  {',
            'vec4 transparent_position = vec4(0.0);',
            'fNormal = normalize(normalMatrix * normal);',
            'vec4 pos = modelViewMatrix * vec4(position,1.0);',
            'fPosition = pos.xyz;',
            'transparent_position = projectionMatrix * pos;',
            'return transparent_position *= 1.0;',
            '}',

        'vec4 electric_main()  {',
            'vec4 electric_position = vec4(0.0);',
            'vUv = uv;',
            'electric_position = projectionMatrix * modelViewMatrix * vec4(position,1.0);','return electric_position *= 1.0;',
            '}',
            
        'void main() {',
            'gl_Position = transparent_main() + electric_main();',
        '}',

    ].join( '\n' ),
    fragmentShader: [
        '#ifdef GL_OES_standard_derivatives',
            '#extension GL_OES_standard_derivatives : enable',
        '#endif', 
        'precision highp float;',
        'precision highp int;',
        'uniform vec3 transparent_color;',
        'uniform float start;',
        'uniform float end;',
        'uniform float alpha;',
        'uniform float time;',
        'uniform vec3 electric_color;',
        'uniform float waverSpeed;',
        'uniform float phaseSpeed;',
        'uniform float thickness;',
        'uniform float contrast;',
        'uniform float electricitySpeed;',
        'uniform float flashSpeed;',
        'uniform float turbulence;',
        'varying vec3 fPosition;',
        'varying vec3 fNormal;',
        'varying vec2 vUv;',
        'const float F3 = 0.3333333;',
        'const float G3 = 0.1666667;',

        'vec3 random3(vec3 c) {',
            'float j = 4096.0 * sin(dot(c,vec3(17.0,59.4,15.0)));',
            'vec3 r;',
            'r.z = fract(512.0 * j);',
            'j *= .125;',
            'r.x = fract(512.0 * j);',
            'j *= .125;',
            'r.y = fract(512.0 * j);',
            'return r - 0.5;',
        '}',

        'float simplex3d(vec3 p) {',
            'vec3 s = floor(p + dot(p,vec3(F3)));',
            'vec3 x = p - s + dot(s,vec3(G3));',
            'vec3 e = step(vec3(0.0),x - x.yzx);',
            'vec3 i1 = e * (1.0 - e.zxy);',
            'vec3 i2 = 1.0 - e.zxy * (1.0 - e);',
            'vec3 x1 = x - i1 + G3;',
            'vec3 x2 = x - i2 + 2.0 * G3;',
            'vec3 x3 = x - 1.0 + 3.0 * G3;',
            'vec4 w,d;',
            'w.x = dot(x,x);',
            'w.y = dot(x1,x1);',
            'w.z = dot(x2,x2);',
            'w.w = dot(x3,x3);',
            'w = max(0.6 - w,0.0);',
            'd.x = dot(random3(s),x);',
            'd.y = dot(random3(s + i1),x1);',
            'd.z = dot(random3(s + i2),x2);',
            'd.w = dot(random3(s + 1.0),x3);',
            'w *= w;',
            'w *= w;',
            'd *= w;',
            'return dot(d,vec4(52.0));',
        '}',

        'float noise(vec3 m) {',
            'return 0.5333333 * simplex3d(m) + 0.2666667 * simplex3d(2.0 * m) + 0.1333333 * simplex3d(4.0 * m) + 0.0666667 * simplex3d(8.0 * m);',
        '}',
        
        'vec4 transparent_main() {',
            //'vec4 transparent_color = vec4(0.0);',
            'if (!gl_FrontFacing) {',
                'discard;',
            '}',
            'vec3 normal = normalize(fNormal);',
            'vec3 eye = normalize(-fPosition.xyz);',
            'float rim = smoothstep(start,end,1.0 - dot(normal,eye));',
            'float value = clamp(rim,0.0,1.0) * alpha;',
            //'vec4 transparent_color = vec4( clamp(rim, 0.0, 1.0) * alpha * color, 0.5);',
            'return vec4( clamp(rim, 0.0, 1.0) * alpha * transparent_color, 0.5);',
        '}',
        
        'vec4 electric_main(void) {',
            //'vec4 electric_color = vec4(0.0);',
            'vec2 uvScaled = vUv.xy * 2.0 - 1.0;',
            'uvScaled.y += waverSpeed * 4.0 * (-0.5 + mod(time * waverSpeed,1.0));',
            'vec3 p3 = vec3(vUv.xy * turbulence,time * electricitySpeed);',
            'float simplexNoise = noise(vec3(p3 * 12.0 + 12.0));',
            'float t = clamp((uvScaled.x * -uvScaled.x * 0.16) + 0.15,0.0,1.0);',
            'float y = abs(simplexNoise * -t + uvScaled.y) * (0.6 + sin(time * flashSpeed));',
            'float g = pow(y,thickness);',
            'float pixel = pow(1.0 - g,contrast);',
            //'electric_color = vec4(pixel * electric_color,pixel);',
            'return vec4(pixel * electric_color,pixel);',
        '}',

        'void main() {',
            'gl_FragColor = (transparent_main() + electric_main());',
        '}'
    ].join( '\n' ),
}    
export {GlowingShader};